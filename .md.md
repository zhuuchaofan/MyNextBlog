# 【算法笔记 05】从“断链焦虑”到“穿针引线”：彻底搞懂 LeetCode 206 反转链表

> 前言：
>
> 在之前的笔记中，我们用“快慢指针”拿下了判环（LeetCode 141）和测距（LeetCode 876）。
>
> 但要想挑战更高阶的题目（比如即将到来的 LeetCode 234 回文链表），我们还缺一块最重要的拼图：修改链表结构的能力。
>
> **LeetCode 206 反转链表**，它是链表世界的 Hello World，也是无数新手“空指针异常”的噩梦源头。今天，我们不背代码，而是用两套思维模型，彻底拆解这个“穿针引线”的过程。

## 01. 既视感：不要试图扭转乾坤

很多初学者（包括以前的我）在做这道题时，脑子里想的是把整条链表“一下子”翻过来。这种宏观视角在写代码时非常危险，因为你很容易顾头不顾尾。

**正确的直觉是“微观聚焦”：**

想象你在排队取餐，所有人把手搭在前面人的肩膀上。

现在教官喊：“向后转！”

你不需要指挥整个队伍，你只需要关注你自己和你前后两个人：

1. **回头看**：记住你原来身后的人（Next），别让他走丢了。
2. **换手**：把手从前面那个人肩上拿开，搭到原来身后那个人的肩上。
3. **移步**：你也变成了新的“前面那个人”。

只要每个人都做对了这个动作，整条队伍自然就反转了。

## 02. 解法一：双指针迭代法 (The Iterative Way)

这是最经典、最符合工程直觉的解法。我们需要凑齐“指针三剑客”。

### 数据定义与解剖 (Data Definition)

- **`curr` (当前视角)**：我是谁？我是当前正要反转节点。
- **`prev` (历史沉淀)**：我去哪？反转后，我应该指向谁？（初始为 `null`）。
- **`next` (未来保障)**：谁接班？为了防止断链，必须先把它存下来。

### 数据的线性生命周期 (Data Lifecycle)

这是本题的**绝对核心**。我们在 `while` 循环的“这一帧”里，变量的流转必须严格遵守 **“保存 -> 斩断 -> 推进”** 的顺序。一旦乱序，链表就会断开。

我们追踪一次循环内部的状态变化：

1. **挂钩未来 (Save Context)**：`next = curr.next`。
   - *潜台词*：“先把后面的路记下来，不然一会回头就忘。”
2. **斩断过去 (Reverse)**：`curr.next = prev`。
   - *潜台词*：“关键一跳！我的指向从‘右’变成了‘左’。”
3. **推进历史 (Shift Window 1)**：`prev = curr`。
   - *潜台词*：“我已经处理完了，我成为了新的‘前驱’。”
4. **迈向未来 (Shift Window 2)**：`curr = next`。
   - *潜台词*：“下一位，该你了。”

### 代码实现

C#

```
public ListNode ReverseList(ListNode head) {
    // 1. 定义状态指针
    ListNode prev = null;
    ListNode curr = head;

    while (curr != null) {
        // 2. 核心三部曲：存 -> 改 -> 移
        // 存：一定要先存下个节点，否则直接改 curr.next 就找不到路了
        ListNode next = curr.next; 

        // 改：将当前节点的指针反转，指向前一个节点
        curr.next = prev;

        // 移：指针窗口整体向后滑动
        prev = curr;
        curr = next;
    }

    // 3. 返回新头
    // 循环结束时 curr 是 null，prev 才是新的头结点
    return prev;
}
```

------

## 03. 解法二：递归法 (The Recursive Way)

如果说迭代法是稳扎稳打的“步兵”，那递归法就是极其抽象的“魔法师”。虽然在工程中因为栈溢出风险不常推荐，但它能极大地训练你的**回溯思维**。

### 核心思维：盗梦空间

递归的本质是“递”到尽头，再从尽头“归”回来。

1. **递 (Dive)**：一直调用自己，直到找到最后一个节点（新头）。
2. **归 (Return)**：在回来的路上，让 `head.next`（也就是你后面的那个人）的 `next` 指向你自己。

**最难理解的一句代码：** `head.next.next = head;`

- 假设当前是节点 `4`，后面是 `5`。
- `head` 是 `4`。
- `head.next` 是 `5`。
- `head.next.next` 就是 **5 的 next**。
- 我们要让 `5` 指向 `4`，所以写成 `head.next.next = head`。

### 代码实现

C#

```
public ListNode ReverseList(ListNode head) {
    // Base Case: 如果是空或者只有一个节点，直接返回
    // 这也是递归的“尽头”，返回的这个 node 将成为新头
    if (head == null || head.next == null) {
        return head;
    }

    // 1. 递：一直往深处走，直到拿到最后一个节点 (newHead)
    ListNode newHead = ReverseList(head.next);

    // 2. 归：在回溯过程中修改指针
    // 这一步是让后一个节点指向当前节点 (构建反向连接)
    head.next.next = head;
    
    // 3. 断：断开原来的连接，防止成环 (4->5 变成了 4<->5，必须断开 4->5)
    head.next = null;

    return newHead;
}
```

------

## 04. 深度复盘与企业级思考

### 1. 为什么要有两种解法？(Method Architecture)

- **迭代法**：空间复杂度 $O(1)$，时间复杂度 $O(N)$。它是**工业界标准**，因为在大数据量下不会爆栈，且没有函数调用的开销。
- **递归法**：空间复杂度 $O(N)$（栈空间），时间复杂度 $O(N)$。它的价值在于**逻辑简洁**，在处理树形结构（Tree）或复杂图算法时，这种思维模式是必须的。

### 2. 避坑指南 (Pitfalls)

- **NullReferenceException**：一定要在最开始处理 `head == null` 的情况。
- **环形引用**：在递归法中，最后必须写 `head.next = null`。如果忘了这一步，链表的尾部（原来的头）会和它的前一个节点形成死循环（A <-> B），导致后续遍历死循环。

### 3. 实战应用 (Production Ready)

在 .NET 的 `System.Collections.Generic.LinkedList<T>` 中，官方实现是一个**双向链表**。但在高频交易、游戏底层（如 Unity ECS 架构）或内存受限的嵌入式设备中，我们依然会手写单向链表池（Node Pool）。

此时，`Reverse` 操作往往不是为了“反转数据”，而是为了**回收资源**。例如，把一个被释放的链表反转后接回 Free List（空闲链表池）的头部，这时候对指针操作的精准控制就是基本功。

------

## 05. 总结

LeetCode 206 不仅仅是一道题，它是对**引用（Reference）**理解深度的试金石。

- **迭代法**教我们要理清**时序**：先存后改。
- **递归法**教我们要理解**回溯**：利用函数栈来保存状态。

当你能闭着眼睛写出 `curr.next = prev` 这个核心逻辑时，恭喜你，你已经拿到了通往下一关的钥匙。

Next Step:

万事俱备，只欠东风。既然我们已经掌握了找中点 (876) 和 反转 (206)，是时候去挑战那个传说中的 Boss 了——LeetCode 234 回文链表。下一篇，我们将见证这两个技巧的“终极缝合”。